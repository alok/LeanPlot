import LeanPlot.Constants
import LeanPlot.Components
import LeanPlot.Palette
import LeanPlot.ToFloat
import LeanPlot.Axis -- For AxisProps used in Recharts
import LeanPlot.API -- For xyArrayToJson
import LeanPlot.Utils -- For jsonDataHasInvalidFloats
import LeanPlot.WarningBanner -- For WarningBanner
import LeanPlot.Core -- For LeanPlot.Render instance
import LeanPlot.Legend -- Add import for Legend
import ProofWidgets.Component.Recharts
import ProofWidgets.Data.Html -- Explicit import for Html.empty and Html.text
import Lean.Server -- For HtmlEval
import LeanPlot.JsonExt -- For jsonHasKeys helper
import LeanPlot.LegacyLayer

open Lean ProofWidgets ProofWidgets.Recharts LeanPlot.Constants
open LeanPlot -- For WarningBannerProps, WarningBanner, Render
open LeanPlot.Utils -- For jsonDataHasInvalidFloats
open LeanPlot.Legend (Legend) -- Open Legend for direct use
open LeanPlot.Components (BarChart AreaChart ComposedChart)
open scoped ProofWidgets.Jsx -- This enables JSX syntax
namespace LeanPlot

/-! # LeanPlot Specification Language
Defines data types for plot specifications (series, axes, styling etc.) that
can be lowered to different concrete back-ends (Recharts, VegaLite etc.).
-/

/--
Specification of a chart axis.

Note that Recharts expects the *domain* as a JSON array `[lo, hi]`, so we
store it as `Array Json` ready for serialisation rather than a tuple of
`Float`s.  When the domain is left as `none`, Recharts will automatically pick
an appropriate range based on the data.
-/
structure AxisSpec where
  /-- Human-readable label shown alongside the axis. -/
  label    : Option String := none
  /-- Field in the chart-level JSON rows that provides the coordinate for this axis. -/
  dataKey  : String
  /-- Axis interpretation, e.g. `"number"` or `"category"`. -/
  type     : Option String := none
  /-- Explicit numeric domain given as `[lo, hi]`. -/
  domain   : Option (Array Json) := none
  deriving ToJson, FromJson, Inhabited

/-- For now, use the legacy type directly as LayerSpec
abbrev LayerSpec := LegacyLayerSpec

-- Maintain compatibility alias for SeriesSpec
abbrev SeriesSpec := LayerSpec

/-- The specification for a plot. -/
structure PlotSpec where
  /-- The data for the chart. -/
  chartData : Array Json := #[]
  /-- The series in the chart. -/
  series    : Array LayerSpec := #[]
  /-- Default x-axis specification. -/
  xAxis     : Option AxisSpec := some { dataKey := "x" }
  /-- Default y-axis specification. -/
  yAxis     : Option AxisSpec := some { dataKey := "y" }
  /-- The title of the plot. -/
  title     : Option String := none
  /-- The width of the plot. -/
  width     : Nat := defaultW
  /-- The height of the plot. -/
  height    : Nat := defaultH
  /-- Whether to show the legend. -/
  legend    : Bool := true
  deriving Inhabited

-- Basic constructor functions

/-- Construct a line plot from a function. -/
@[inline]
def line {β} [ToFloat β]
  (fn : Float → β) (name : String := "y") (steps : Nat := 200)
  (domainOpt : Option (Float × Float) := none)
  (color : Option String := none) : PlotSpec :=
  let (minVal, maxVal) : Float × Float :=
    match domainOpt with
    | some d => d
    | none   => (-1.0, 1.0)

  let data : Array Json :=
    if steps == 0 then #[] else
      (List.range (steps.succ)).toArray.map fun i =>
        let x : Float := minVal + (maxVal - minVal) * i.toFloat / steps.toFloat
        let y : β := fn x
        Json.mkObj [
          ("x", toJson x),
          (name, toJson (toFloat y))
        ]

  let seriesColor := color.getD (LeanPlot.Palette.colorFromNat 0)
  {
    chartData := data,
    series := #[{
      name      := name,
      dataKey   := name,
      color     := seriesColor,
      type      := "line"
    }],
    xAxis     := some { dataKey := "x", label := some "x" },
    yAxis     := some { dataKey := name, label := some name },
    legend    := true
  }

/-- Construct a scatter plot from an array of points. -/
@[inline]
def scatter (points : Array (Float × Float)) (name : String := "y")
  (color : Option String := none) : PlotSpec :=
  let data := LeanPlot.API.xyArrayToJson points
  let seriesColor := color.getD (LeanPlot.Palette.colorFromNat 0)
  {
    chartData := data,
    series := #[{
      name      := name,
      dataKey   := "y", -- `xyArrayToJson` produces {x:_, y:_}
      color     := seriesColor,
      type      := "scatter"
      -- dot is not applicable for scatter
    }],
    xAxis     := some { dataKey := "x", label := some "x" }, -- Default x-axis label
    yAxis     := some { dataKey := "y", label := some name },
    legend    := !(name == "y")
  }

/-- Construct a bar chart from an array of points.
Each tuple encodes an `(x,y)` pair which will be converted to the
`{x := _, y := _}` JSON objects expected by Recharts. -/
@[inline]
def bar (points : Array (Float × Float)) (name : String := "y")
  (color : Option String := none) : PlotSpec :=
  let data := LeanPlot.API.xyArrayToJson points
  let seriesColor := color.getD (LeanPlot.Palette.colorFromNat 0)
  {
    chartData := data,
    series := #[{
      name      := name,
      dataKey   := "y", -- `xyArrayToJson` produces objects with `y` by default
      color     := seriesColor,
      type      := "bar"
    }],
    xAxis     := some { dataKey := "x", label := some "x" },
    yAxis     := some { dataKey := "y", label := some name },
    legend    := !(name == "y")
  }

/-- Construct an area chart from a function. -/
@[inline]
def area {β} [ToFloat β]
  (fn : Float → β) (name : String := "y") (steps : Nat := 200)
  (domainOpt : Option (Float × Float) := none)
  (color : Option String := none) : PlotSpec :=
  let (minVal, maxVal) : Float × Float :=
    match domainOpt with
    | some d => d
    | none   => (-1.0, 1.0)

  let data : Array Json :=
    if steps == 0 then #[] else
      (List.range (steps.succ)).toArray.map fun i =>
        let x : Float := minVal + (maxVal - minVal) * i.toFloat / steps.toFloat
        let y : β := fn x
        Json.mkObj [
          ("x", toJson x),
          (name, toJson (toFloat y))
        ]

  let seriesColor := color.getD (LeanPlot.Palette.colorFromNat 0)
  {
    chartData := data,
    series := #[{
      name      := name,
      dataKey   := name,
      color     := seriesColor,
      type      := "area"
    }],
    xAxis     := some { dataKey := "x", label := some "x" },
    yAxis     := some { dataKey := name, label := some name },
    legend    := true
  }

/-- Construct a multi-line chart from several functions sampled on a common domain.
Each `(name, fn)` pair becomes its own series. The colors are automatically
assigned from the default palette unless `colors?` is provided. -/
@[inline]
def lines {β} [Inhabited β] [ToFloat β]
  (fns : Array (String × (Float → β)))
  (steps : Nat := 200)
  (domainOpt : Option (Float × Float) := none)
  (colors? : Option (Array String) := none) : PlotSpec :=
  let (minVal, maxVal) : Float × Float :=
    match domainOpt with
    | some d => d
    | none   => (-1.0, 1.0)
  let data : Array Json :=
    if steps == 0 then #[] else
      LeanPlot.Components.sampleMany fns steps minVal maxVal
  -- Determine colors
  let chosenColors : Array String :=
    match colors? with
    | some cs =>
      if cs.size >= fns.size then cs
      else
        cs ++ (List.range (fns.size - cs.size)).toArray.map (fun i => LeanPlot.Palette.colorFromNat (cs.size + i))
    | none => (List.range fns.size).toArray.map LeanPlot.Palette.colorFromNat
  let seriesArr : Array LayerSpec :=
    (List.range fns.size).toArray.map fun idx =>
      let (name, _) := fns[idx]!; {
        name      := name,
        dataKey   := name,
        color     := chosenColors[idx]!,
        type      := "line"
      : LayerSpec }
  {
    chartData := data,
    series    := seriesArr,
    xAxis     := some { dataKey := "x", label := some "x" },
    yAxis     := none, -- let Recharts auto-label or user can set later
    legend    := true
  }

-- Combinators

namespace PlotSpec

/-- Set the title of the plot. -/
@[inline]
def withTitle (spec : PlotSpec) (t : String) : PlotSpec :=
  { spec with title := some t }

/-- Set the width of the plot. -/
@[inline]
def withWidth (spec : PlotSpec) (w : Nat) : PlotSpec :=
  { spec with width := w }

/-- Set the height of the plot. -/
@[inline]
def withHeight (spec : PlotSpec) (h : Nat) : PlotSpec :=
  { spec with height := h }

/-- Set the width and height of the plot. -/
@[inline]
def withSize (spec : PlotSpec) (w h : Nat) : PlotSpec :=
  { spec with width := w, height := h }

/-- Set the x-axis label of the plot. -/
@[inline]
def withXLabel (spec : PlotSpec) (label : String) : PlotSpec :=
  match spec.xAxis with
  | some xAxisSpec => { spec with xAxis := some { xAxisSpec with label := some label } }
  | none           => { spec with xAxis := some { label := some label, dataKey := "x" } }

/-- Set the y-axis label of the plot. -/
@[inline]
def withYLabel (spec : PlotSpec) (label : String) : PlotSpec :=
  match spec.yAxis with
  | some yAxisSpec => { spec with yAxis := some { yAxisSpec with label := some label } }
  | none           => { spec with yAxis := some { label := some label, dataKey := "y" } }
  -- Note: dataKey for yAxis might need to be smarter if multiple series exist

/-- Show or hide the legend. -/
@[inline]
def withLegend (spec : PlotSpec) (shouldShow : Bool) : PlotSpec :=
  { spec with legend := shouldShow }

/-- Set the x-axis domain. -/
@[inline]
def withXDomain (spec : PlotSpec) (min max : Float) : PlotSpec :=
  let newDomain := #[toJson min, toJson max]
  match spec.xAxis with
  | some xAxisSpec => { spec with xAxis := some { xAxisSpec with domain := some newDomain } }
  | none           => { spec with xAxis := some { dataKey := "x", domain := some newDomain } }

/-- Set the y-axis domain. -/
@[inline]
def withYDomain (spec : PlotSpec) (min max : Float) : PlotSpec :=
  let newDomain := #[toJson min, toJson max]
  match spec.yAxis with
  | some yAxisSpec => { spec with yAxis := some { yAxisSpec with domain := some newDomain } }
  | none           => { spec with yAxis := some { dataKey := "y", domain := some newDomain } }

/-- Append a new series to the plot. The caller must ensure that `spec.chartData` already provides the data for `series.dataKey`. -/
@[inline]
def addSeries (spec : PlotSpec) (series : LayerSpec) : PlotSpec :=
  { spec with series := spec.series.push series, legend := true }

/-- Overlay two `PlotSpec`s by concatenating their `series` arrays and combining metadata.
    NOTE: This assumes both specs refer to the *same* `chartData` (same x‐values).
    If the datasets differ the function keeps `p.chartData` and discards `q.chartData`.
    Axis specs prefer the first non-`none` value encountered.  Width/height take the max. -/
@[inline] def overlay (p q : PlotSpec) : PlotSpec :=
  { chartData := p.chartData ++ q.chartData,
    series    := p.series ++ q.series,
    xAxis     := match p.xAxis with | some x => some x | none => q.xAxis,
    yAxis     := match p.yAxis with | some y => some y | none => q.yAxis,
    title     := none,
    width     := max p.width q.width,
    height    := max p.height q.height,
    legend    := true }

/-- Synonym for `overlay` inspired by grammar-of-graphics "stacking". -/
@[inline] def stack := overlay

instance : HAdd PlotSpec PlotSpec PlotSpec where
  hAdd := overlay

/-- Add a line layer to an existing plot, merging its data into the existing chartData. -/
@[inline] def addLine {β} [ToFloat β]
    (spec : PlotSpec) (f : Float → β) (name : String) (color : Option String := none)
    (stepsOverride : Option Nat := none) (domainOverride : Option (Float × Float) := none) : PlotSpec :=

  let xKey := (spec.xAxis.getD {dataKey := "x"}).dataKey
  let effectiveSteps := stepsOverride.getD 200

  let newLayer : LayerSpec := {
    name    := name,
    dataKey := name,
    color   := color.getD (LeanPlot.Palette.colorFromNat spec.series.size),
    type    := "line"
  }

  let toJsonNumAsFloatOption (j : Json) : Option Float :=
    match j.getNum? with
    | Except.ok jsonNum => some (jsonNum.toFloat)
    | Except.error _ => none

  if spec.chartData.isEmpty then
    let defaultDomain : Float × Float := (-1.0, 1.0)
    let (minVal, maxVal) : Float × Float :=
      domainOverride.getD <| spec.xAxis.bind (·.domain) |> fun domOpt =>
        match domOpt with
        | some arr =>
          if arr.size == 2 then
            match toJsonNumAsFloatOption arr[0]!, toJsonNumAsFloatOption arr[1]! with
            | some v0, some v1 => (v0, v1)
            | _, _ => defaultDomain
          else defaultDomain
        | none => defaultDomain

    let newData : Array Json :=
      if effectiveSteps == 0 then #[] else
        (List.range (effectiveSteps.succ)).toArray.map fun i =>
          let x : Float := minVal + (maxVal - minVal) * i.toFloat / effectiveSteps.toFloat
          let yVal := toJson (toFloat (f x))
          Json.mkObj [(xKey, toJson x), (name, yVal)]
    { spec with
        chartData := newData,
        series    := spec.series.push newLayer,
        legend    := true }
  else
    let updatedChartData := spec.chartData.map fun obj =>
      match obj.getObjVal? xKey with
      | Except.ok xJson =>
        match toJsonNumAsFloatOption xJson with
        | some xFloat =>
          let yVal := toJson (toFloat (f xFloat))
          obj.setObjVal! name yVal
        | none => obj -- xKey's value was not a number or not a float
      | Except.error _ => obj -- xKey not found
    { spec with
        chartData := updatedChartData,
        series    := spec.series.push newLayer,
        legend    := true }

/-- Add a scatter layer to an existing plot. (Needs similar data merging logic as addLine for robust composition) -/
@[inline] def addScatter
    (spec : PlotSpec) (points : Array (Float × Float)) (name : String) (color : Option String := none) : PlotSpec :=
  let newSpec := LeanPlot.scatter points name color -- LeanPlot.scatter is in the LeanPlot namespace
  spec.overlay newSpec

/-- Add a bar layer to an existing plot. -/
@[inline] def addBar
    (spec : PlotSpec) (points : Array (Float × Float)) (name : String) (color : Option String := none) : PlotSpec :=
  let newSpec := LeanPlot.bar points name color -- LeanPlot.bar is in the LeanPlot namespace
  spec.overlay newSpec

-- Renderer Typeclass

/-- A typeclass for rendering a layer specification into HTML. -/
class RenderFragment (α : Type) where
  /-- Renders a layer specification into HTML.
      `layerSpec` is the specification for the individual layer.
      `allChartData` is the complete dataset for the chart, passed in case the renderer needs it. -/
  render (layerSpec : α) (allChartData : Array Json) : Html

/-- Deprecated: Use `RenderFragment` instead. -/
abbrev RenderSeries (α : Type) := RenderFragment α

-- Default instance for `LayerSpec` dispatching on its `type` field.
instance : RenderFragment LayerSpec where
  render (s : LayerSpec) (_allChartData : Array Json) : Html :=
    if s.type == "line" then
      (<Line type={LineType.monotone} dataKey={toJson s.dataKey} stroke={s.color} dot?={some (s.dot.getD false)} /> : Html)
    else if s.type == "scatter" then
      let scatterProps : LeanPlot.Components.ScatterProps := { dataKey := toJson s.dataKey, fill := s.color }
      (<LeanPlot.Components.Scatter {...scatterProps} /> : Html)
    else if s.type == "area" then
      let areaProps : LeanPlot.Components.AreaProps := { dataKey := toJson s.dataKey, fill := s.color, stroke := s.color }
      (<LeanPlot.Components.Area {...areaProps} /> : Html)
    else if s.type == "bar" then
      let barProps : LeanPlot.Components.BarProps := { dataKey := toJson s.dataKey, fill := s.color }
      (<LeanPlot.Components.Bar {...barProps} /> : Html)
    else
      (Html.text s!"Unsupported series type: {s.type}" : Html)

instance : RenderFragment AxisSpec where
  render (_ax : AxisSpec) (_allChartData : Array Json) : Html := (Html.text "AxisSpec Fragment (dummy)" : Html)

/-- Render the plot according to its `PlotSpec`. -/
@[inline] def render (spec : PlotSpec) : Html :=
  let chartComponents := spec.series.map fun s =>
    RenderFragment.render s spec.chartData
  let xAxisHtml := match spec.xAxis with
    | some ax =>
      let label? : Option Json := ax.label.map Json.str
      let axProps : LeanPlot.Axis.AxisProps := {
        dataKey? := some (toJson ax.dataKey),
        domain? := ax.domain,
        label? := label?,
        type := .number
      }
      (<LeanPlot.Axis.XAxis {...axProps} /> : Html)
    | none => (Html.text "" : Html)

  -- Rotate the Y-axis label by –90 ° and place it to the left of the tick labels
  let yAxisHtml := match spec.yAxis with
    | some ax =>
      let labelJson? : Option Json := ax.label.map fun l =>
        Json.mkObj [
          ("value", Json.str l),
          ("angle", toJson (-90.0)),
          ("position", Json.str "left")
        ]
      let axProps : LeanPlot.Axis.AxisProps := {
        dataKey? := some (toJson ax.dataKey),
        domain? := ax.domain,
        label? := labelJson?,
        type := .number
      }
      (<LeanPlot.Axis.YAxis {...axProps} /> : Html)
    | none => (Html.text "" : Html)

  let legendHtml := if spec.legend then (<Legend /> : Html) else (Html.text "" : Html)

  let allAre (t : String) : Bool := spec.series.all (fun s => s.type == t)

  -- Check if we have mixed chart types
  let chartTypes := spec.series.map (fun s => s.type) |>.toList.eraseDups
  let isMixed := chartTypes.length > 1

  let mainChartComponent : Html :=
    if isMixed then
      -- Use ComposedChart for mixed types
      (<ComposedChart width={spec.width} height={spec.height} data={spec.chartData}>
        {xAxisHtml}
        {yAxisHtml}
        {legendHtml}
        {... chartComponents}
      </ComposedChart> : Html)
    else if allAre "bar" then
      (<BarChart width={spec.width} height={spec.height} data={spec.chartData}>
        {xAxisHtml}
        {yAxisHtml}
        {legendHtml}
        {... chartComponents}
      </BarChart> : Html)
    else if allAre "area" then
      (<AreaChart width={spec.width} height={spec.height} data={spec.chartData}>
        {xAxisHtml}
        {yAxisHtml}
        {legendHtml}
        {... chartComponents}
      </AreaChart> : Html)
    else
      (<LineChart width={spec.width} height={spec.height} data={spec.chartData}>
        {xAxisHtml}
        {yAxisHtml}
        {legendHtml}
        {... chartComponents}
      </LineChart> : Html)

  let finalHtml := match spec.title with
    | some t => (<div><h4>{Html.text t}</h4>{mainChartComponent}</div> : Html)
    | none => mainChartComponent
  let keysToCheck := spec.series.map (fun s => s.dataKey) |>.push "x"
  if LeanPlot.Utils.jsonDataHasInvalidFloats spec.chartData keysToCheck then
    let warningProps : LeanPlot.WarningBannerProps := { message := "Plot data contains invalid values (NaN/Infinity) and may not render correctly." }
    let warningHtml := LeanPlot.WarningBanner warningProps
    (.element "div" #[] #[warningHtml, finalHtml] : Html)
  else
    finalHtml

/-!
Automatically validate that every row in `spec.chartData` contains **all** keys
referenced by the plot at *compile-time*.  The required keys are:

* the primary coordinate field used by the x-axis (defaults to `"x"` when the
  caller does not override `AxisSpec.dataKey`); and
* every `dataKey` referenced by the series array.

If *any* JSON row is missing *any* of these keys the elaborator raises an
error, preventing invalid `PlotSpec`s from compiling.  Users therefore no
longer need to invoke `#assert_keys` manually.
-/

instance : HtmlEval PlotSpec where
  eval spec := do
    -- 1. Collect the x-axis key (defaulting to "x" when absent).
    let xKey : String :=
      match spec.xAxis with
      | some ax => ax.dataKey
      | none    => "x"

    -- 2. Collect all series data keys and append the x-axis key.
    let requiredKeys : Array String :=
      (spec.series.map (fun s => s.dataKey)).push xKey

    -- 3b. Ensure series names and dataKeys are unique – duplicated names lead
    --     to runtime clashes in Recharts (legend/tooltips).  We detect this
    --     statically to fail fast.
    let mut nameSet : Std.HashSet String := {}
    let mut dataKeySet : Std.HashSet String := {}
    let mut dupNames : Std.HashSet String := {}
    let mut dupKeys  : Std.HashSet String := {}
    for s in spec.series do
      if nameSet.contains s.name then
        dupNames := dupNames.insert s.name
      nameSet := nameSet.insert s.name

      if dataKeySet.contains s.dataKey then
        dupKeys := dupKeys.insert s.dataKey
      dataKeySet := dataKeySet.insert s.dataKey

    if !dupNames.isEmpty || !dupKeys.isEmpty then
      let formatList (hs : Std.HashSet String) : String :=
        String.intercalate ", " hs.toList
      let nameMsg :=
        if dupNames.isEmpty then "" else s!" series names: {formatList dupNames}"
      let keyMsg  :=
        if dupKeys.isEmpty  then "" else s!" dataKeys: {formatList dupKeys}"
      let connector := if !dupNames.isEmpty && !dupKeys.isEmpty then "; " else ""
      throwError s!"LeanPlot: duplicate{connector}{nameMsg}{keyMsg} detected – each series must use a unique `name` and `dataKey`."

    -- 4. Check every JSON object in `chartData` contains *all* required keys.
    let allRowsHaveKeys : Bool :=
      spec.chartData.all fun obj => LeanPlot.jsonHasKeys obj requiredKeys

    unless allRowsHaveKeys do
      throwError "LeanPlot: chartData is missing required keys {requiredKeys}"

    -- 5. Delegate to the usual renderer when validation succeeds.
    pure (render spec)

universe u

instance {β : Type u} [Inhabited β] : Inhabited (String × (Float → β)) where
  default := ("", fun _ => default)

instance : Render PlotSpec where
  render := render

end PlotSpec

end LeanPlot
